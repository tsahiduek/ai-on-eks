"use strict";(self.webpackChunkdoeks_website=self.webpackChunkdoeks_website||[]).push([[8532],{6910:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>l,contentTitle:()=>r,default:()=>p,frontMatter:()=>s,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"guidance/container-startup-time/reduce-container-image-size/optimize-image-size","title":"Optimizing container images size","description":"Selecting appropriate base images","source":"@site/docs/guidance/container-startup-time/1-reduce-container-image-size/12-optimize-image-size.md","sourceDirName":"guidance/container-startup-time/1-reduce-container-image-size","slug":"/guidance/container-startup-time/reduce-container-image-size/optimize-image-size","permalink":"/ai-on-eks/docs/guidance/container-startup-time/reduce-container-image-size/optimize-image-size","draft":false,"unlisted":false,"editUrl":"https://github.com/awslabs/ai-on-eks/blob/main/website/docs/guidance/container-startup-time/1-reduce-container-image-size/12-optimize-image-size.md","tags":[],"version":"current","sidebarPosition":12,"frontMatter":{"sidebar_label":"Optimizing container images size"},"sidebar":"guidance","previous":{"title":"Reducing container image size","permalink":"/ai-on-eks/docs/guidance/container-startup-time/reduce-container-image-size/"},"next":{"title":"Decoupling model artifacts from container image","permalink":"/ai-on-eks/docs/guidance/container-startup-time/reduce-container-image-size/decoupling-model-artifacts"}}');var a=n(74848),o=n(28453);const s={sidebar_label:"Optimizing container images size"},r="Optimizing container images size",l={},c=[{value:"Selecting appropriate base images",id:"selecting-appropriate-base-images",level:2},{value:"Using multi-stage builds",id:"using-multi-stage-builds",level:2},{value:"Employing layer optimization techniques",id:"employing-layer-optimization-techniques",level:2}];function d(e){const i={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(i.header,{children:(0,a.jsx)(i.h1,{id:"optimizing-container-images-size",children:"Optimizing container images size"})}),"\n",(0,a.jsx)(i.h2,{id:"selecting-appropriate-base-images",children:"Selecting appropriate base images"}),"\n",(0,a.jsx)(i.p,{children:"Different AI/ML frameworks and platforms offer ready-to-use container images, providing convenience and enabling experimentation. However, these images often try to address as wide a feature set as possible and thus may include different runtimes, frameworks, or supported APIs, leading to bloat that is unsuitable for production container images."}),"\n",(0,a.jsxs)(i.p,{children:["For example, different PyTorch image variants have very different sizes: from ",(0,a.jsx)(i.a,{href:"https://hub.docker.com/layers/pytorch/pytorch/2.7.1-cuda11.8-cudnn9-devel/images/sha256-5a046e4e3364b063a17854387b8820ad3f42ed197a089196bce8f2bd68f275a8",children:"2.7.1-cuda11.8-cudnn9-devel"})," (6.66 GB) that includes development tools, compilers etc. to ",(0,a.jsx)(i.a,{href:"https://hub.docker.com/layers/pytorch/pytorch/2.7.1-cuda11.8-cudnn9-runtime/images/sha256-8d409f72f99e5968b5c4c9396a21f4b723982cfdf2c1a5b9cc045c5d0a7345a1",children:"2.7.1-cuda11.8-cudnn9-runtime"})," (3.03 GB) that contains runtime only. The vLLM project ",(0,a.jsx)(i.a,{href:"https://docs.vllm.ai/en/stable/contributing/dockerfile/dockerfile.html",children:"provides"})," several container image variants, each with different capabilities packaged in, such as the OpenAI spec, Sagemaker integration, and more."]}),"\n",(0,a.jsx)(i.p,{children:"Selecting a smaller base image that satisfies the needs of the application can make a big difference, with a caveat \u2013 smaller runtime-only images may not include JIT compilation or dynamic optimization and thus fall on the slower code paths, reducing startup time."}),"\n",(0,a.jsx)(i.p,{children:"A production-oriented comprehensive approach would include:"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"benchmarking workloads with different base images"}),"\n",(0,a.jsx)(i.li,{children:"considering custom builds that include only required optimization libraries"}),"\n",(0,a.jsx)(i.li,{children:"testing overall cold start performance in addition to image pull time improvements"}),"\n"]}),"\n",(0,a.jsx)(i.h2,{id:"using-multi-stage-builds",children:"Using multi-stage builds"}),"\n",(0,a.jsx)(i.p,{children:"Multi-stage container image builds, supported by multiple platforms such as Docker/BuildKit, Podman, Finch/Buildkit, allow use of multiple FROM statements in a single container image file to separate build process and artifacts from the runtime concerns."}),"\n",(0,a.jsx)(i.p,{children:"A multi-stage build container image file may look similar to the following:"}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{children:'# Build stage that also uses an external image to copy artifacts\nFROM python:3.12-slim-bookworm AS builder\nCOPY --from=ghcr.io/astral-sh/uv:0.7.11 /uv /uvx /bin/\n...\n\n# Runtime stage\nFROM python:3.12-slim-bookworm\n...\nCOPY --from=models some-model /app/models/some-model/configs\nCOPY --from=builder --chown=app:app /app/.venv ./.venv\nCOPY --from=builder --chown=app:app /app/main.py ./main.py\n...\nCMD ["sh", "-c", "exec fastapi run --host 0.0.0.0 --port 80 /app/main.py"]\n'})}),"\n",(0,a.jsx)(i.admonition,{type:"info",children:(0,a.jsx)(i.p,{children:"Unlike typical application dependencies baked into container images, copying large model files (ranging from a few GBs to tens of GBs) is generally discouraged. This is due to increased container image size which affect its pull time, separate release lifecycle for the app and model, and potential storage duplication when sharing models across multiple apps."})}),"\n",(0,a.jsx)(i.p,{children:"Copying only the required artifacts allows fine-grained control over which components of the build result are to be included in the final runtime image, reducing its size (along with other benefits, like security or workflow simplicity)."}),"\n",(0,a.jsxs)(i.p,{children:["In the example above we also employed two other ",(0,a.jsx)(i.a,{href:"https://docs.docker.com/reference/dockerfile/#copy---from",children:"variations"})," of ",(0,a.jsx)(i.code,{children:"COPY --from"}),"  (supported via BuildKit by the majority of popular image building platforms) :"]}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.code,{children:"COPY --from=<path/to/image/in/registry and parts to be taken>"})," allows to extract only the specific files and folders from another container image stored in a registry"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.code,{children:"COPY --from=<name of the build context>"})," allows to copy only the specific files and folders from a local folder, provided as a parameter to the build command using ",(0,a.jsx)(i.code,{children:"--build-context models=/path/to/local/folder"})]}),"\n"]}),"\n",(0,a.jsxs)(i.p,{children:["Note that while using ",(0,a.jsx)(i.code,{children:".dockerignore"})," is a good practice, in general, and should be used alongside the above process, it doesn\u2019t impact the ",(0,a.jsx)(i.code,{children:"COPY --from=..."})," commands."]}),"\n",(0,a.jsx)(i.p,{children:"Additionally this technique can be further (if sometimes marginally) improved by using the following one, taking caveats into consideration."}),"\n",(0,a.jsx)(i.h2,{id:"employing-layer-optimization-techniques",children:"Employing layer optimization techniques"}),"\n",(0,a.jsx)(i.p,{children:"As image layers (now smaller in total size) are downloaded during the pull process, they are decompressed and unpacked to assemble the container\u2019s file system. The amount and size of the image layers have an impact of the duration of that process, serving as another candidate for optimization."}),"\n",(0,a.jsxs)(i.p,{children:["One commonly mentioned optimization involves combining the ",(0,a.jsx)(i.code,{children:"RUN"})," or ",(0,a.jsx)(i.code,{children:"COPY"})," commands to create smaller amount of larger layers, with the following typical example:"]}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{children:"FROM ...\nRUN apt-get update && \\\n    apt-get install -y --no-install-recommends \\\n        build-essential \\\n        libssl-dev \\\n        pkg-config && \\\n    rm -rf /var/lib/apt/lists/* && \\\n    apt-get clean\n"})}),"\n",(0,a.jsxs)(i.p,{children:["In context of the recommendation to employ multi-stage builds, ",(0,a.jsx)(i.code,{children:"RUN"})," isn\u2019t often a part of the last \u2013 runtime stage. This is because, ideally, all execution is done during the previous build stages and the processed artifacts are only copied into their intended locations in the runtime stage."]}),"\n",(0,a.jsxs)(i.p,{children:["The ",(0,a.jsx)(i.code,{children:"COPY"})," command, in the runtime stage, can be optimized using this process, with one challenge \u2013 it doesn\u2019t support multiple destinations or multiple source stages, so combining these commands into one isn\u2019t possible:"]}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{children:"COPY --from=models some-model /app/models/some-model/configs\nCOPY --from=builder1 --chown=app:app /app/.venv ./.venv\nCOPY --from=builder1 --chown=app:app /app/main.py ./main.py\nCOPY --from=builder2 --chown=app:app /app/config.json ./config.json\n"})}),"\n",(0,a.jsx)(i.p,{children:"To overcome this, an additional copying stage may be introduced, where the final folder structure is created and then copied via a single command:"}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{children:'FROM python:3.12-bookworm AS builder1\nWORKDIR /app\n...\n\nFROM pytorch/pytorch:2.7.1-cuda11.8-cudnn9-devel AS builder2\nWORKDIR /app\n...\n\nFROM scratch AS assembly\n...\nCOPY --from=models some-model/weights /app/models/some-model/weights\nCOPY --from=builder1 /app/.venv /app/venv\nCOPY --from=builder1 /app/main.py /app/main.py\nCOPY --from=builder2 /dist/config.json /app/config.json\n\nFROM python:3.12-slim-bookworm\nCOPY --from=assembly --chown=app:app /app /app\nCMD ["python", "main.py"]\n'})}),"\n",(0,a.jsx)(i.p,{children:"Take into consideration that even when the above steps have a positive effect on the overall container startup time, it is often negligible, relative to other solutions in this guide and should be assessed before investing time into the technique."}),"\n",(0,a.jsx)(i.p,{children:"The improvement should be weighted against the trade-offs that include:"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"reduction in cache efficiency, due to its lower granularity with a smaller amount of larger layers if layers are not ordered correctly"}),"\n",(0,a.jsx)(i.li,{children:"build time, due to more shuffling for the sake of optimization of the runtime layer"}),"\n"]})]})}function p(e={}){const{wrapper:i}={...(0,o.R)(),...e.components};return i?(0,a.jsx)(i,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},28453:(e,i,n)=>{n.d(i,{R:()=>s,x:()=>r});var t=n(96540);const a={},o=t.createContext(a);function s(e){const i=t.useContext(o);return t.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function r(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),t.createElement(o.Provider,{value:i},e.children)}}}]);
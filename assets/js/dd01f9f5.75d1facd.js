"use strict";(self.webpackChunkdoeks_website=self.webpackChunkdoeks_website||[]).push([[8678],{28453:(e,t,r)=>{r.d(t,{R:()=>i,x:()=>o});var a=r(96540);const n={},s=a.createContext(n);function i(e){const t=a.useContext(s);return a.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:i(e.components),a.createElement(s.Provider,{value:t},e.children)}},87506:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>p,frontMatter:()=>i,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"guidance/container-startup-time/accelerate-pull-process/index","title":"Accelerating pull process","description":"The solutions in this section reduce the container startup time by improving the image pull process. They do it by either relying on the images\u2019 layered internal structure and changing how their layers are retrieved over the network from a container registry or by skipping the registry altogether.","source":"@site/docs/guidance/container-startup-time/2-accelerate-pull-process/index.md","sourceDirName":"guidance/container-startup-time/2-accelerate-pull-process","slug":"/guidance/container-startup-time/accelerate-pull-process/","permalink":"/ai-on-eks/docs/guidance/container-startup-time/accelerate-pull-process/","draft":false,"unlisted":false,"editUrl":"https://github.com/awslabs/ai-on-eks/blob/main/website/docs/guidance/container-startup-time/2-accelerate-pull-process/index.md","tags":[],"version":"current","frontMatter":{"sidebar_label":"Accelerating pull process"},"sidebar":"guidance","previous":{"title":"Decoupling model artifacts from container image","permalink":"/ai-on-eks/docs/guidance/container-startup-time/reduce-container-image-size/decoupling-model-artifacts"},"next":{"title":"Using containerd snapshotter","permalink":"/ai-on-eks/docs/guidance/container-startup-time/accelerate-pull-process/containerd-snapshotter"}}');var n=r(74848),s=r(28453);const i={sidebar_label:"Accelerating pull process"},o="Accelerating pull process",c={},l=[];function d(e){const t={a:"a",code:"code",h1:"h1",header:"header",p:"p",...(0,s.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.header,{children:(0,n.jsx)(t.h1,{id:"accelerating-pull-process",children:"Accelerating pull process"})}),"\n",(0,n.jsx)(t.p,{children:"The solutions in this section reduce the container startup time by improving the image pull process. They do it by either relying on the images\u2019 layered internal structure and changing how their layers are retrieved over the network from a container registry or by skipping the registry altogether."}),"\n",(0,n.jsxs)(t.p,{children:["Container images are composed of layers, implemented by content-addressable blobs, stored in registries like Amazon ECR. When a pod is scheduled onto a worker node, the container runtime, typically ",(0,n.jsx)(t.code,{children:"containerd"}),", retrieves and mounts these read-only layers using a union file-system, such as ",(0,n.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/OverlayFS",children:"OverlayFS"}),", then attaches a writable, ephemeral layer on top to complete the container filesystem."]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.code,{children:"containerd"})," is implemented as a modular container runtime with several pluggable components. A snapshotter,  which is the focus of the first two solutions, is a pluggable component that is responsible for the assembly of the image layers. The default OverlayFS snapshotter fully unpacks image layers to disk before container start and does not support lazy or partial layer extraction. Only after all layers are unpacked and mounted via OverlayFS can the container\u2019s unified filesystem be presented."]}),"\n",(0,n.jsx)(t.p,{children:"The last step of the process described above is  blocking and sequential, and thus has a very significant impact on the container startup time."}),"\n",(0,n.jsx)(t.p,{children:"Instead of fully extracting each layer to disk, advanced snapshotters, such as SOCI (Seekable OCI) or Nydus, create virtual, mountable snapshots, lazy-loading files from a registry or a remote storage as they are accessed, which has a lower I/O overhead and drastically improves container startup time."}),"\n",(0,n.jsx)(t.p,{children:"Instead of improving the pull process by optimizing container image layers retrieval and storage, the last solution prefetches all the image layers onto a data volume, into the container runtime cache, of a Bottlerocket EC2 machine during a CI/CD process. The process then takes a snapshot of the volume to be mounted onto EKS Bottlerocket worker nodes, creating a warmed-up cached for the container runtime on them."})]})}function p(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}}}]);